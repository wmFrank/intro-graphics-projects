# Hw6完成了所有的基础题和加分题
### 实验结果
- 实验结果放在images文件夹下，其中包含了：
binary_naive.ppm 基础题得到的图片，使用中位数划分的BVH加速结构。
binary_sah.ppm 加分题得到的图片，使用SAH划分的BVH加速结构。
- 性能对比：
中位数划分：建立加速结构耗时：0.35s，渲染耗时：7.84s。
SAH划分：建立加速结构耗时：0.86s，渲染耗时：6.39s。
- 结果分析：
可以看出SAH建立加速结构的时间更长，但是渲染耗时更少。建立加速结构时间更长的原因是每次划分都需要根据SAH的代价公式来计算最优的划分方法，因此会多出计算开销；渲染的耗时更少是因为利用SAH建立出来的树在对每条光线求交时计算代价更小。
- 运行说明：
切换中位数划分或者SAH划分需要修改的地方有：Scene.cpp的12、13行 以及 
Triangle.hpp的126、127行。

### 实验思路
- 光线和包围盒求交
根据课上讲的方法，分别按照x,y,z方向求出三个方向的t_min和t_max，然后t_min中最大的得到t_enter，t_max中最小的得到t_exit，然后判断是否满足t_enter < t_exit && t_exit >= 0，若满足则说明光线和包围盒相交。
- 光线和加速结构求交
这里很自然使用递归来做，如果当前节点是叶节点，那么调用光线和三角形相交的函数得到交点，如果当前不是叶节点，则光线分别和左右子树求交，然后取其中离光源近的交点返回。
- 中位数划分和SAH划分
对于每一次包围盒的划分，默认是采用中位数划分，做法是选择最长的一个轴作为划分轴，然后使用对三角形进行排序，然后取中间一个三角形进行划分，使得每次划分左右两边的三角形数量相等。
如果使用SAH划分，同样是选择最长的一个轴作为划分轴，同样是对三角形进行排序，然后利用SAH的代价函数对可能的划分分别计算代价（我这里采用32个均匀划分点），取其中代价最小的一种划分作为最终的划分。这里基于的理论前提是假设光线是均匀分布的，那么光线与包围盒相交就和包围盒的表面积有关。我在BVH.cpp中实现了recursiveBuild_SAH()函数来实现SAH划分。

